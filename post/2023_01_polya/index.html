<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>Pólya tree processes (part 1) |
Martin Trapp</title><meta charset=utf-8><meta name=generator content="Hugo 0.113.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Martin Trapp"><meta name=description content="<b>Martin Trapp</b>
AoF Postdoctoral Researcher
Aalto University, Finland"><link rel=stylesheet href=/website/scss/main.min.209ac3069bd66875a9747016db87629b234fb27a5d3ac87930e239cc107ae809.css integrity="sha256-IJrDBpvWaHWpdHAW24dimyNPsnpdOsh5MOI5zBB66Ak=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/website/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/website/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/website/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/website/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/website/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/websitefavicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/websiteapple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/websitefavicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/websitefavicon-16x16.png><link rel=canonical href=https://trappmartin.github.io/website/post/2023_01_polya/><script type=text/javascript src=/website/js/anatole-header.min.60d341ff47e4478c4cf55e16709c98de3e4468032d771e116364535efea16619.js integrity="sha256-YNNB/0fkR4xM9V4WcJyY3j5EaAMtdx4RY2RTXv6hZhk=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trappmartin.github.io/website/images/site-feature-image.png"><meta name=twitter:title content="Pólya tree processes (part 1)"><meta name=twitter:description content="Welcome to the first more &ldquo;technical&rdquo; post. In this post, I will have a look at the Pólya tree process and look at some basic properties of it."><meta property="og:title" content="Pólya tree processes (part 1)"><meta property="og:description" content="Welcome to the first more &ldquo;technical&rdquo; post. In this post, I will have a look at the Pólya tree process and look at some basic properties of it."><meta property="og:type" content="article"><meta property="og:url" content="https://trappmartin.github.io/website/post/2023_01_polya/"><meta property="og:image" content="https://trappmartin.github.io/website/images/site-feature-image.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-03T00:00:00+00:00"><meta property="og:site_name" content="Almost surely"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Pólya tree processes (part 1)","headline":"Pólya tree processes (part 1)","alternativeHeadline":"","description":"
      
        Welcome to the first more \u0026ldquo;technical\u0026rdquo; post. In this post, I will have a look at the Pólya tree process and look at some basic properties of it.


      


    ","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trappmartin.github.io\/website\/post\/2023_01_polya\/"},"author":{"@type":"Person","name":"Martin Trapp"},"creator":{"@type":"Person","name":"Martin Trapp"},"accountablePerson":{"@type":"Person","name":"Martin Trapp"},"copyrightHolder":{"@type":"Person","name":"Martin Trapp"},"copyrightYear":"2023","dateCreated":"2023-01-03T00:00:00.00Z","datePublished":"2023-01-03T00:00:00.00Z","dateModified":"2023-01-03T00:00:00.00Z","publisher":{"@type":"Organization","name":"Martin Trapp","url":"https://trappmartin.github.io/website","logo":{"@type":"ImageObject","url":"https:\/\/trappmartin.github.io\/websitefavicon-32x32.png","width":"32","height":"32"}},"image":["https://trappmartin.github.io/website/images/site-feature-image.png"],"url":"https:\/\/trappmartin.github.io\/website\/post\/2023_01_polya\/","wordCount":"1767","genre":[],"keywords":["BNP"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
."><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/website/images/picture2.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/website>Almost surely</a></div><div class=sidebar__introduction-description><p><b>Martin Trapp</b><br>AoF Postdoctoral Researcher<br>Aalto University, Finland</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://github.com/trappmartin target=_blank rel="noopener me" aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://ellis.social/@trappmartin target=_blank rel="noopener me" aria-label=Mastodon title=Mastodon><i class="fab fa-mastodon fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href="https://scholar.google.com/citations?user=GwCrZP4AAAAJ" target=_blank rel="noopener me" aria-label="Google Scholar" title="Google Scholar"><i class="fas fa-graduation-cap fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://orcid.org/0000-0003-1725-3381 target=_blank rel="noopener me" aria-label=ORCiD title=ORCiD><i class="fab fa-orcid fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:martin.trapp@aalto.fi target=_blank rel="noopener me" aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Martin Trapp
2023</li></ul></footer><script type=text/javascript src=/website/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script><script defer type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity=sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN crossorigin=anonymous></script>
<script type=text/x-mathjax-config>
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script></div></aside><main class=wrapper__main><header class=header><div class=.><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/website/ title>Home</a></li><li class=nav__list-item><a href=/website/post/ title>Notes / Blog</a></li><li class=nav__list-item><a href=/website/publications/ title>Publications</a></li></ul><ul class="nav__list nav__list--end"></ul></nav></div></header><div class="post
."><div class=post__content><h1>Pólya Tree Processes (Part 1)</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>3/1/2023</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>9-minute read</span></li></ul><p>Welcome to the first more &ldquo;technical&rdquo; post.
In this post, I will have a look at the Pólya tree process and look at some basic properties of it.
I believe this is an excellent topic for a first technical post, as it combines many research directions I am very excited about.
In particular, Pólya trees provide a principled way of specifying a Bayesian nonparametric prior over arbitrary<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> probability distributions (i.e., the complexity of the generated distribution is dependent on the data complexity) while at the same time having a <em>closed-form</em> posterior and allowing tractable inferences of moments.</p><h2 id=preliminaries>Preliminaries</h2><p>In order to be somewhat rigorous, I will briefly introduce some basic notation.
Let \((X, \mathcal{A})\) be a measurable space with sample space \(X\) and a suitable sigma-algebra<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> \(\mathcal{A}\) on \(X\) (e.g., the Borel algebra if \(X\) is a topological space).
See <a href=#1>[1]</a> or <a href=#2>[2]</a> for details.
Next, we equip the space with a probability measure, that is, a function \(\mathbb{P} \colon \mathcal{A} \to [0,1]\) assigning each &ldquo;event&rdquo; \(A \in \mathcal{A}\) some probability value. As usually done, we will assume that \(\mathbb{P}\) is an additive set function, i.e. \(\mathbb{P}(A \cup B) = \mathbb{P}(A) + \mathbb{P}(B)\), and that the probability of \(X\) is one.</p><h2 id=pólya-tree-process>Pólya tree process</h2><p>In Pólya trees (e.g., <a href=#3>[3]</a>, <a href=#4>[4]</a>) we are concerned with generating \(\Bbb{P}\) in a <em>constructive</em> way.
Loosely speaking, Pólya tree processes define a generative process that constructs a probability measure recursively.
Historically, these processes have been investigated in the search for a family of processes that is more flexible than the Dirichlet process, whose draws are almost surely discrete.
Interestingly the Pólya tree processes can generate discrete and continuous distributions depending on their parameterization.
In the broader context, Pólya tree processes are a special case of trail-free processes <a href=#4>[4]</a>.</p><p>In the Pólya tree process, we first recursively partition the sample space \(X\) into dyadic partitions, i.e.,
$$
\begin{aligned}
\Pi^0 &= \lbrace X \rbrace = \lbrace A_0 \cup A_1 \rbrace \\
\Pi^1 &= \lbrace A_0, A_1 \rbrace = \lbrace A_{00} \cup A_{01}, A_{10} \cup A_{11} \rbrace \\
\Pi^2 &= \lbrace A_{00}, A_{01}, A_{10}, A_{11} \rbrace \\
&= \lbrace A_{000} \cup A_{001}, A_{010} \cup A_{011}, A_{100} \cup A_{101}, A_{110} \cup A_{111} \rbrace \\
&\vdots \\
\Pi^j &= \lbrace A_{\epsilon0} \cup A_{\epsilon1} \mid \epsilon \in \lbrace 0,1\rbrace^j \rbrace \\
&\vdots \\
\end{aligned}
$$
which continues infinitely and can be visualized as a tree:<figure><img src=../figures/2023_01_polya/figure1.svg alt="Illustration of a recursive partitioning"></figure></p><p>Next, we associate each set \(A\) in the tree with a conditional probability \(\theta(A)\) following an independent beta distribution \(\text{Beta}(\alpha(A_{\epsilon0}), \alpha(A_{\epsilon1}))\).
Note that I am using \(\alpha(A)\) to denote the parameters of the beta distribution as a function of \(A\).
By following the described generative processes, we are <em>constructing</em> a random probability measure with sigma-algebra generated by the partition tree.</p><h3 id=example>Example</h3><p>As an example, let the sample space be given as \(X = (0,1] ]\) and let us partition the sample space recursively by cutting each sub-space in the middle.
Then we obtain,
$$
\begin{aligned}
\Pi^0 &= \lbrace X \rbrace &=& \lbrace (0,1] \rbrace \\
\Pi^1 &= \lbrace A_0, A_1 \rbrace &=& \lbrace (0,\frac{1}{2}], (\frac{1}{2},1] \rbrace \\
\Pi^2 &= \lbrace A_{00}, A_{01}, A_{10}, A_{11} \rbrace &=& \lbrace (0,\frac{1}{4}], (\frac{1}{4},\frac{2}{4}], (\frac{2}{4},\frac{3}{4}], (\frac{3}{4},1] \rbrace \\
&\vdots
\end{aligned}
$$</p><p>In practice, we truncate the Pólya tree processes to a finite depth. For example, Hanson <a href=#6>[6]</a> suggested truncating the tree based on the number of observations heuristically.
In a future post, I will discuss truncations and the implications of truncating a Pólya tree process in detail.
For now, let us assume that we truncate the process at depth \(J=2\), i.e., we obtain a tree with \(2^J = 4\) leaves and \(\frac{2^{J+1} - 2}{2} = 3\) parameters where we assume that \(\theta(A_{\epsilon0}) \sim \text{Beta}\) and \(\theta(A_{\epsilon1}) = 1 - \theta(A_{\epsilon0})\). Then, given draws for each \(\theta(A_{\epsilon0})\), the probability \(\Bbb{P}(A)\) is given by the product of conditional probabilities/variables on the path from the root to \(A\), for example, the probability of \(A_{010}\) is:
$$
\Bbb{P}(A_{010}) = \theta(A_0) \theta(A_{01}) \theta(A_{010}) = \theta(A_0) (1 -\theta(A_{00})) \theta(A_{010}) .
$$</p><h3 id=inference>Inference</h3><p>The <strong>cool</strong> thing about Pólya trees is that posterior inference essentially boils down to <em>counting</em>, as we can leverage the conjugacy of the beta-binomial experiment to perform exact inference. Meaning the posterior for each \(\theta(A)\) is simply:
$$
\theta(A_\epsilon) \mid x_1, \ldots, x_n \sim \text{Beta}(\alpha(A_{\epsilon0}) + n(A_{\epsilon0}), \alpha(A_{\epsilon1}) + n(A_{\epsilon1})) \tag{1}
$$
where \(n(A)\) denotes the number of observations in \(A\).
This nice and simple form is one of the attractive properties of Pólya trees compared to other nonparametric priors over continuous distributions.</p><h3 id=properties>Properties</h3><p>We can influence the properties of the Pólya tree by changing the behavior of the beta parameters.
A common choice is to tie the parameters for each level and let them only depend on the depth.
By doing so, one can enforce discreteness of the random probability measure under certain choices of \(\alpha\) <a href=#5>[5]</a> and obtain the <em>Dirichlet process</em> as a special case when choosing: <a href=#4>[4]</a>
$$
\alpha(A_\epsilon) = 2^{-|\epsilon|} . \tag{2}
$$
Below is a random draw from the posterior of a Pólya tree process truncated to a depth of 10 levels conditioned on observations drawn from a mixture of Gaussians (dashed lines) with \(\alpha\) set as in Eq. (2).<figure><img src=../figures/2023_01_polya/figure2_1.svg alt="Random posterior draws"></figure></p><p>Another popular choice is to ensure that \(\Bbb{P}\) has a density wrt to the Lebesgue measure. This can achieved by choosing:
$$
\alpha(A_\epsilon) = |\epsilon| 2^{2 |\epsilon| \gamma} , \tag{3}
$$</p><p>where \(0 &lt; \gamma &lt; 1\) <a href=#7>[7]</a>, resulting in an optimal minimax convergence rate for estimating an assumed density (wrt supremum norm). I refer to <a href=#7>[7]</a> for details.
The figure below illustrates two random draws from the posterior (solid and dash-dotted) using Eq. (3) with \(\gamma = 0.3\) on the same data as before.<figure><img src=../figures/2023_01_polya/figure2_2.svg alt="Random posterior draws"></figure></p><p>Even though the generated density functions look reasonable, they are not very smooth in part due to the independence assumption made in the prior processes.
A common way to overcome the challenges in obtaining smooth continuous density functions is to use a mixture of Pólya trees <a href=#6>[6]</a>. An alternative strategy is to introduce additional latent variables <a href=#8>[8]</a>.
Another drawback is that the dyadic points (we assumed them to always be in the middle for now) play a crucial role in the posterior of a truncated tree. In fact, it might be preferable to adjust the dyadic tree to the data, e.g., by using a mixture of different dyadic trees.</p><p>Further note that, for now, we have always assumed that \(\alpha\) is tied for each level. However, in practice, one might want to vary the shape parameters depending on the data complexity. Ma <a href=#8>[8]</a> proposed an interesting perspective on the precision parameters of the beta priors as <em>shrinkage parameters</em>. This perspective stems from the observation that the posterior mean can be decomposed into a weighted average of the prior mean and the proportion of probability mass assigned to region A. This shrinkage away from the prior mean in the posterior is controlled by the prior variance, hence, the name shrinkage parameter.
I will discuss this approach and other recent advancements to scale Pólya trees to higher dimensional data in the next post on Pólya trees.</p><h3 id=relationship-to-probabilistic-circuits>Relationship to Probabilistic Circuits</h3><p>Somewhat surprisingly, Pólya trees are related to probabilistic circuits, a family of tractable probabilistic models that has recently gained increasing attention.
In a preliminary study, we have shown <a href=#9>[9]</a> that certain constructions<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> of Bayesian probabilistic circuits (probabilistic circuits with Bayesian priors on their parameters) are truncated Pólya tree processes in disguise.</p><h2 id=codes-to-reproduce-the-plots>Codes to reproduce the plots</h2><p>The code below illustrates how to implement Pólya trees for 1D data in Julia and uses a parametric family as centering distribution, as suggested in <a href=#5>[5]</a>.
Note that the implementation is fairly simple, and computing densities under a J-level truncated Pólya tree process is \(\mathcal{O}(J)\).</p><details><summary>Julia code</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Julia data-lang=Julia><span style=display:flex><span><span style=color:#66d9ef>using</span> Distributions, StatsBase, LogarithmicNumbers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># map obervation to A in jth layer</span>
</span></span><span style=display:flex><span>kfun(x<span style=color:#f92672>::</span><span style=color:#66d9ef>AbstractFloat</span>, j<span style=color:#f92672>::</span><span style=color:#66d9ef>Int</span>, base<span style=color:#f92672>::</span><span style=color:#66d9ef>Distribution</span>) <span style=color:#f92672>=</span> min(floor(<span style=color:#66d9ef>Int</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>j <span style=color:#f92672>*</span> cdf(base, x)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>j)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># count observations in each A</span>
</span></span><span style=display:flex><span>ns(x<span style=color:#f92672>::</span><span style=color:#66d9ef>AbstractVector</span>, J<span style=color:#f92672>::</span><span style=color:#66d9ef>Int</span>; base <span style=color:#f92672>=</span> Uniform(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> map(j <span style=color:#f92672>-&gt;</span> counts(kfun<span style=color:#f92672>.</span>(x, j, base), <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>j), <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>J)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># draw conditional probabilities</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> thetas(n<span style=color:#f92672>::</span><span style=color:#66d9ef>Vector</span>{<span style=color:#66d9ef>Vector</span>{<span style=color:#66d9ef>Int</span>}}; α <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, ρ <span style=color:#f92672>=</span> (j) <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>2.0</span><span style=color:#f92672>^</span>(<span style=color:#f92672>-</span>j))
</span></span><span style=display:flex><span>    θs <span style=color:#f92672>=</span> map(layer <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                 j, nj <span style=color:#f92672>=</span> layer
</span></span><span style=display:flex><span>                 m <span style=color:#f92672>=</span> reshape(nj, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>(j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                 θl <span style=color:#f92672>=</span> map(i <span style=color:#f92672>-&gt;</span> ULogarithmic<span style=color:#f92672>.</span>(rand(Beta( α <span style=color:#f92672>*</span> ρ(j) <span style=color:#f92672>.+</span> m[<span style=color:#f92672>:</span>,i]<span style=color:#f92672>...</span>))), <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>(j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                 mapreduce(θ <span style=color:#f92672>-&gt;</span> [θ, one(θ) <span style=color:#f92672>-</span> θ], vcat, θl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>, enumerate(n))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> θs
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># compute probabilities</span>
</span></span><span style=display:flex><span>prob(x, θs, base) <span style=color:#f92672>=</span> mapreduce( ((j, θ),) <span style=color:#f92672>-&gt;</span> θ[kfun<span style=color:#f92672>.</span>(x, j, base)], (a,b) <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>.*</span> b, enumerate(θs) )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>probmf(x, θs, base) <span style=color:#f92672>=</span> prob(x, θs, base)
</span></span><span style=display:flex><span>probdf(x, θs, base) <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>J <span style=color:#f92672>*</span> prob(x, θs, base) <span style=color:#f92672>.*</span> pdf<span style=color:#f92672>.</span>(base, x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Random<span style=color:#f92672>.</span>seed!(<span style=color:#ae81ff>123</span>)
</span></span><span style=display:flex><span>mix <span style=color:#f92672>=</span> MixtureModel([Normal(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0.1</span>), Normal(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.5</span>)], [<span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.8</span>])
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> rand(mix, <span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>minx, maxx <span style=color:#f92672>=</span> minimum(x)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, maximum(x)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>base <span style=color:#f92672>=</span> Uniform(minx, maxx)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>J <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> ns(x, J; base <span style=color:#f92672>=</span> base)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Figure 1</span>
</span></span><span style=display:flex><span>xtest <span style=color:#f92672>=</span> range(minimum(x) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, maximum(x) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, length<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>ytest <span style=color:#f92672>=</span> probmf(xtest, thetas(n; ρ <span style=color:#f92672>=</span> (j) <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>2.0</span><span style=color:#f92672>^</span>(<span style=color:#f92672>-</span>j)), base)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Figure 2</span>
</span></span><span style=display:flex><span>xtest <span style=color:#f92672>=</span> range(minimum(x) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, maximum(x) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, length<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>ytest1 <span style=color:#f92672>=</span> probdf(xtest, thetas(n, ρ <span style=color:#f92672>=</span> (j) <span style=color:#f92672>-&gt;</span> j<span style=color:#f92672>*</span><span style=color:#ae81ff>2.0</span><span style=color:#f92672>^</span>(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>j<span style=color:#f92672>*</span><span style=color:#ae81ff>0.3</span>)), base)
</span></span><span style=display:flex><span>ytest2 <span style=color:#f92672>=</span> probdf(xtest, thetas(n, ρ <span style=color:#f92672>=</span> (j) <span style=color:#f92672>-&gt;</span> j<span style=color:#f92672>*</span><span style=color:#ae81ff>2.0</span><span style=color:#f92672>^</span>(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>j<span style=color:#f92672>*</span><span style=color:#ae81ff>0.3</span>)), base)
</span></span></code></pre></div></details><hr><h2 id=references>References</h2><p><a id=1>[1]</a> René Schilling.
<em>Measures, Integrals and Martingales.</em>
Cambridge University Press, 2005.</br><a id=2>[2]</a> Terence Tao.
<em>An Introduction to Measure Theory.</em>
American Mathematical Society, 2011.</br><a id=3>[3]</a> Michael Lavine.
<em>Some aspects of Pólya tree distributions for statistical modelling.</em>
The Annals of Statistics, 20(3):1222–1235, 1992.</br><a id=4>[4]</a> Thomas S. Ferguson.
<em>Prior Distributions on Spaces of Probability Measures.</em>
Annals of Statistics, 2(4):615-629, 1974.</br><a id=5>[5]</a> David Blackwell.
<em>Discreteness of Ferguson Selections.</em>
Annals of Statistics, 1(2):356-358, 1973.</br><a id=6>[6]</a> Timothy E Hanson.
<em>Inference for Mixtures of Finite Pólya Tree Models.</em>
Journal of the American Statistical Association, 101(476):1548-1565, 2006.</br><a id=7>[7]</a> Ismaël Castillo
<em>Pólya tree posterior distributions on densities.</em>
Annales de l&rsquo;Institut Henri Poincaré, Probabilités et Statistiques, 53(4), 2017.</br><a id=8>[8]</a> Li Ma.
<em>Adaptive Shrinkage in Pólya Tree Type Models.</em>
Bayesian Analysis, 12(3), 2017.</br><a id=9>[9]</a> Martin Trapp and Arno Solin.
<em>On Priors in Bayesian Probabilistic Circuits and Multivariate Pólya Trees.</em>
Preliminary results presented at TPM Workshop at UAI, 2022.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Arbitrary is somewhat of an overstatement. The family of distributions is limited to those having discontinuous probability measures. However, extensions of Pólya trees (such as mixtures) can generate a larger family. It might be interesting to characterize the families of distributions that various extensions of Pólya trees can generate.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>It is optional to know what a sigma-algebra is to follow the post. In short, think of a collection of subsets of (X\) that we want to measure. This collection must follow some rules, i.e., it needs to contain the empty set and the set \(X\), and has to be closed under finite unions and complements.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>These constructions are rather common in the literature.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><div class=post__footer><span><a class=tag href=/website/tags/bnp/>BNP</a></span></div><div id=comment><h2>comments</h2><script src=https://utteranc.es/client.js repo=trappmartin/website issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Martin Trapp
2023</li></ul></footer><script type=text/javascript src=/website/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script><script defer type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity=sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN crossorigin=anonymous></script>
<script type=text/x-mathjax-config>
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script></body></html>